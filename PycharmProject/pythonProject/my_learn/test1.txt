# 数据类型转换
    type(x) 返回数据类型字符串
    int(x) 将x转换为一个整数
    float(x)
    str(x)
    上面三个函数同样有返回值

# 运算符
    +
    -
    *
    /
    //
    %
    **

# 字符串
1. 字符串格式化
name = "黑马程序员"
message = "学IT就来 %s" % name
print(message)
% 标识要占位

多个变量占位要使用括号括起来，并按照占位的顺序填入
message = "学IT就来 %s %s" % (name1,name2)

常用占位符
%s %d %f

2. 格式化的精度控制
%5d %5.2f 默认空格补齐

3. 格式化2
f"内容{变量}"的格式来快速格式化
name = "传智播客"
set_up_year = 2006
print(f"我是{name},我成立于：{set_up_year}") 不关心格式 直接显示原本的内容

4. 对表达式进行格式化
表达式： 一条具有明确执行结果的代码语句
如：1+1，5*2...
直接格式化表达式
print("1 * 1的结果是：%d" % (1*1))
print(f"1 * 1的结果是：{1*1}")
print("字符串在Python中的类型是：%s" % type('字符串'))

# 数据输入
1. input语句
name = input()
name = input("请告诉我你的银行密码")

# bool类型
True / False
1 /0

# if语句的基本格式
if 要判断的条件:
    条件成立时，要做的事情

# if else 语句
if 条件:
    语句1
    ...
else
    语句2
    ...

# if elif else 语句
if 条件:
    语句1
    ...
elif
    语句2
    ...
else
    ...

# while语句
while 条件:
    ...
    ...
    ...

# for 循环
for 临时变量 in 待处理数据集(序列):
    ...

# range语句
range(num)
range(num1,num2)
range(num1,num2,step)

# for 循环中的变量作用域
for i range(5):
    print(i)
print(i) 能否访问？ 答：规范上不可以，实际上可以写出

# continue 和 break 循环中断

# 函数
1. 函数的基础定义
def 函数名(传入参数):
    函数体
    return 返回值
2. 传参定义
def add(x,y):
    result = x+y
    print(result)
add(5,6) 调用函数
3.函数返回值的定义

4. 函数返回值值None类型
如果函数不使用return语句返回的话，那么直接返回None
None表示:空的，无实际意义的值

def check_age(age):
    if age>18:
        return "SUCCESS"
    else:
        return None
result = check_age(16)

if not result:
    print("未成年,不可以进入")

# 函数的说明文档
def func(x,y):
    """
    函数说明
    :param x: 形参x的说明
    :param y: 形参y的说明
    :return：返回值的说明
    """
    函数体
    return

# 函数的嵌套调用：
所谓函数的嵌套调用指的是一个函数里面又调用了另外一个函数
def func_b():
    print("---2---")

def func_a():
    print("---1---")
    func_b()

# 函数中变量的作用域
1. 局部变量

2. 全局变量
   使用global关键字可以在函数内部声明变量为全局变量
   num = 100
   def testA():
        print(num)

   def testB():
        global num
        num = 200
        print(num)
   testA()
   test(B)

# 数据容器
1. 数据容器可以存储多个元素的Python数据类型
2.
    list(列表) 可以修改
    tuple(元组) 不可以修改
    str(字符串)
    set(集合)
    dict(字典)

# list(列表)
1. 列表定义
   (1) 字面量
   [元素1,元素2,元素3,元素4,...]
   (2) 定义变量
   变量名词 = [元素1,元素2,元素3,元素4]
   (3) 定义空列表
   变量名称 = []
   变量名称 = list()
2.列表的下标索引
   (1) 正向下标
   0,1,2,3...
   (2) 反向下标
   -5,-4,-3,-2,-1
   从-1开始递减
3. 列表的常用操作
   (1) 查询
   查找元素的下标
   语法：列表.index(元素)
   (2) 修改
   语法：列表[下标]=值
   (3) 插入
   语法：列表.insert(下标,元素)，在指定的下标位置，插入指定的元素
   (4) 尾部追加
   方式1 语法：列表.append(元素)
   方式2 语法：列表.extend(其他数据容器)，将其他数据容器的内容取出，依次追加到列表末尾
   (5) 删除
   语法1：del 列表[下标]
   语法2：列表.pop(下标)
   6. 删除某元素在列表中的匹配项
   语法1： 列表.remove(元素)
   7. 统计某元素在列表内的数量
   语法：列表.count(元素)
   8. len(列表) 返回表长
   9. 列表.clear() 清空列表
4. 列表的循环遍历
    (1) while循环遍历列表
    index = 0
    while index < len(列表):
        元素 = 列表[index]
        对元素进行处理
        index+=1
    (2) for循环遍历列表
    for i in L:
        ...

# tuple(元组)
1. 元组一旦定义完成就不可以修改
2. 定义
    (元素,)
    元组名 = (元素,)
    空元组
    变量名称 = ()
    变量名称 = tuple()
3. 尝试修改元组的内容会直接报错


# 字符串
1. 通过下标取值
    my_str[idx]
2. index方法
    下标索引值 = my_str.index("字符串")
3. replace方法
    字符串.replace(字符串1,字符串2)
    将字符串内的：字符串1 替换为字符串2
    注意：不是修改字符串本身，而是得到了一个新字符串
4. split方法
    字符串.split(分割符字符串)
    功能：按照指定的分隔符字符串，将字符串划分为多个
         字符串，并存入列表对象中
    注意：字符串本身不变，而是得到了一个列表对象
5. strip方法
   字符串的规整操作(去前后空格)
   语法：字符串.strip()
   字符串的规整操作(去前后指定字符串)
   语法：字符串.strip("12")
   注意：传入“12”其实就是“1”和“2”都会移除，是按照单个字符
6. 统计字符串中某字符串的出现次数
   字符串.count(字符串)
7. 统计字符串的长度
   len(字符串)

# 数据容器的切片操作
1. 什么是序列
    序列是指：内部连续，有序，可使用下标索引的一类数据容器
    列表，元组，字符串均可以视为序列
2. 切片
   序列支持切片操作
   切片：从一个序列中，取出一个子序列
   语法：序列[起始下标:结束下标:步长]
   表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列
   步长为负数，反向去，（注意，起始下标和结束下标也要反向标记）
   mylist = [0,1,2,3,4,5,6]
   result1 = my_list[1:4]

# set(集合)
1. set的定义
    集合不允许重复
    {元素,}
2. 添加新元素
    集合.add(元素)
3. 移除元素
    集合.remove(元素)
4. 随机取出一个元素
    集合.pop(),从集合中随机取出一个元素
    结果：会得到一个元素，同时集合本身被修改，元素被移除
5. 清空集合
    集合.clear()
6. 取两个集合的差集
    set1 = {1,2,3}
    set2 = {1,5,6}
    set3 = set1.difference(set2) 取出集合1有而集合2没有的
7. 消除两个集合的差集
    set1 = {1,2,3}
    set2 = {1,5,6}
    set1.difference_update(set2) 在集合1内，删除和集合2相同的元素
8. 两个集合合并
    set1 = {1,2,3}
    set2 = {1,5,6}
    set3 = set1.union(set2)
9. 统计集合元素的数量
    len(set1)
10. 集合的变量
    集合不支持使用下标索引，不能用while循环
    for element in set1:
        ...

# dict(字典,映射)
1. 定义
    {key:value,key:value}
    {"于腾":99,}
2. 定义重复key的字典
    my_dict1 = {"于腾":99,"于腾":88}
    print(my_dict) => {"于腾":88}
    字典不允许key的重复
3. 访问字典元素
    my_dict["于腾"]
3. 字典的嵌套
    Key和Value可以是任意数据类型（Key不可为字典）
4. 新增元素
    字典[Key] = Value
5. 更新元素
    字典[Key] = Value
4. 删除元素
    字典.pop(Key)
5. 清空字典
    字典.clear()
6. 获取全部的key
    字典.keys() 返回一个列表
7. 遍历字典
    for key in keys:
        ...my_dice[key]
    for key in my_dict: 效果完全和上面一样还是去key
        ...my_dice[key]
8. 统计字典元素数量
    len(字典)

# 数据容器的通用操作
1. len()
2. max()
3. min()
4. 类型转换
   （1）容器转列表 list(容器)
   （2）容器转元组 tuple(容器)
   （3）容器转字符串
   ...
5. 容器排序
    sorted(序列,[reverse=True]) reverse=True表示降序

# 字符串大小比较方式


# 函数的多返回值
def test_return():
    return 1,2
x,y = test_return()

# 函数的多种传参方式
1. 位置参数
    调用函数时根据函数定义的参数位置来传递参数
        传统方式
    注意：传递的参数和定义的参数的顺序及个数必须一致
2. 关键字参数
    函数调用时可以通过‘键=值’形式传递参数
    作用：可以让函数更加清晰，容易使用，同时也消除了参数的顺序需求
    def user_info(name,age,gender):
        ...
    # 关键字传参
    userinfo(name="小明",age="男",gender="男")
    # 可以不按照固定顺序

    # 可以让位置参数混使，位置参数必须在前，且匹配参数顺序
    userinfo("小明",age=20,gender="男")
    注：函数调用时，如果有位置参数时，位置参数必须在关键参数的前面，但关键字参数之间不存在前后顺序
3. 缺省参数(默认值)
    def user_info(name,age,gender='男'):
        ...
    默认的参数必须写到最后面

4. 不定长参数（可变参数）
    (1) 位置传递的不定长
    def user_info(*args):
        print(args)
    args是元组类型，这就是位置传递
    user_info('TOM')
    user_info('TOM',19)
    (2) 关键字传递的不定长
    def user_info(**kwargs):
        print(kwargs)
    args是字典类型，这就是关键字传递
    user_info('name':'TOM','age':18,'id':110)

# 匿名函数
1. 函数作为参数传递
    def test_func(compute):
        result = compute(1,2)
        print(result)
    def compute(x,y):
        return x+y
    test_func(compute)

    这是一种计算逻辑的传递，而不是数据的传递
2. lamda匿名函数
    lamda关键字可以定义匿名函数(无名称)
    语法：lambda 传入参数: 函数体(一行代码)
    注意：只能写一行
    def test_func(compute):
        result = compute(1,2)
        print(result)
    test_func(lamda x,y : x+y)

# 文件读写
1. 文件编码
2. 文件的读取操作
    (1) open(name,mode,encoding)
    例如：
    f = open('python.txt','r',encoding='UTF')
    注意：此时的'f'是'open'函数的文件对象
    (2) read()方法:
    文件对象.read(num)
    num表示要从文件中读取的数据的长度（单位是字节），默认传入所有数据

    注意连续使用两次read会有记忆特性，第二次read会从第一次结尾处第一次读取
    (3) readlines()方法:
    readlines()可以按照行的方式把整个文件中的内容进入一次性的读取，并且返回
    的是一个列表，其中每一行的数据为一个元素。
    (4) for循环读取文件行
    for line in f:
        print(line)
    (5) 文件的关闭
    f.close()
    (6) with open 语法操作文件 文件会自动被close
    with open('D:/测试.txt','r',encoding='UTF-8') as f:
        for line in f:
            print(line)
2. 文件的写入操作
    (1) 文件写入
        f.write('hello world')
        注意调用write,内容并没有真正
        写入文件，而是会积攒在程序的内存中，
        称为缓冲区，当调用flush时，内容才会
        真正的写入文件，这样做是避免频繁的
        操作硬盘，导致效率下降
    (2) 内容刷新
        f.flush()
    (3) 注意
        写入文件使用open函数的'w'模式进行写入
        w模式，文件不存在会创建新文件
        w模式，文件存在会清空原有内容
        close()方法，带有flush()方法的功能
3. 文件的追加操作 a模式打开
    (3) 注意
        写入文件使用open函数的'w'模式进行写入
        a模式，文件不存在会创建新文件
        a模式，文件存在会在最后追加内容写入
        可以使'/n'来写出换行符

# 异常
   1. 异常的概念
   当检测到一个错误时，Python解释器无法继续执行，
   反而出现了有些错误的提示，这就是所谓的异常，也是我们说的”BUG“
   2. 异常的捕获方法
    当我们的程序遇到了BUG，那么接下来有两种情况
    (1) 整个程序因为一个BUG停止运行
    (2) 对BUG进行提醒，整个程序继续运行
        捕获异常的作用在于：提前假设某处出现异常，
        当真的出现异常的时候，可以用后续手段
    (3) 基本捕获方法
        try:
            可能发生错误的代码
        except:
            如果出现异常执行的代码
        try:
            f=open("D:/abc.txt",'r',encoding='UTF-8')
        except:
            print('出现异常了，因为文件不存在，我将open的模式，改为w模式去开')
            f=open("D:/abc.txt",'w',encoding='UTF-8')
    3. 捕获指定的异常
        try:
            print(name)
        except NameError as a:
            出现了变量未定义的异常

        try:
            1/0
        except NameError as a:
            出现了变量未定义的异常
        无法捕获，只捕获指定的异常 e是异常的对象 print(e)可以看到异常的信息
    4. 捕获多个异常
        try:
            可能发生错误的代码
        except (NameError,ZeroDivisionError):
            如果出现异常执行的代码
    5. 捕获所有异常
        try:
            可能发生错误的代码
        except (NameError,ZeroDivisionError):
            如果出现异常执行的代码
        else:
            没有异常
        finally:
             有没有异常都要执行

    6.异常的传递性
        异常是具有传递性的

# 模块
1. 什么是模块
Python模块(Module),是一个Python文件,以.py结尾,模块能定义函数,类和变量,模块里也能包含可执行的代码。
2. 模块的导入
[from 模块名] import [模块 | 类 | 变量 | 函数 | *] [as 别名]
常用的组合形式:
import 模块名
from 模块名 import 类,变量,方法等
from 模块名 import *
import 模块名 as 别名
from 模块名 import 功能名 as 别名
注意: 通过.表示层级关系
3. 自定义模块并导入
自己定义一个.py文件，然后就可以直接在别的py文件中import 文件名
调用的时候 自定义模块名.xxx
4. __name__ == '__main__' 变量 在定于以模块的 执行语句里面
 __name__  内置变量
这样当直接包调用的时候下面的代码才会执行，而被别人调用的时候不会被执行
5. __all__ 变量
当使用'from xxx import *'导入时候，才能导入这个列表中的元素
__all__ = ['test_A']
def test_A():
    print('testA')
def test_B():
    print('testB')

# Python包
1. 自定义包
从物理上看,包就是文件夹，在该文件夹下包含了一个__init__.py
文件，该文件夹可用于包含多个模块文件，从逻辑上看，包的本质依然是模块

创建包:

导入包:
import 包名.模块名
from 包名 import 模块名
from 包名 import * 模块名.目标
__all__ = ["包中可以用的模块的名字"]
注意：__all__ 针对的是'from... import' 这种方式 对于 import xxx 无效
2. 安装第三方包
使用 pip 安装第三方包
pip install 包名称
pip install 包名称 -i 指定网站


# json数据格式
1. 使用json模块
import json
deat=...
data = json.dumps(data) # 将py数据转为json数据
data = json.loads(data) # 将json数据转为py数据
如果有中文可以带上：ensure_ascii= False参数来确保中文正常转缓

# pyecharts模块
...








# 面向对象
1.声明对象
class Student:
    name = None

2.创建对象
stu_1 = Student()

3.为对象属性赋值
stu1.name=...
4.获取对象的信息
print(stu1.name)

4.类的成员方法
class 类名称:
    def 方法名(self,形参,...):
        如果要访问类内部的变量要通过self.变量名

5.类和对象

6.构造方法
class 类名称:
    name = None 可以省略
    def __init__(self,形参名):

7.内置方法(魔术方法)
    __init__ 构造方法

    __str__ 字符串方法
    通过__str__方法,控制类转换为字符串的行为
    __lt__ 小于大于符号比较
    直接对两个对象进行比较是不可以的，但是在
    类中实现__lt__方法,即可同时完成:小于大于两种符号的比较
    def __lt__(self,other):
        return self.age < other.age（other,另外一个对象）
    __le__ 小于等于，大于等于符号比较

    __eq__ ==符号比较

8.封装
    私有成员变量
        __变量名
    私有成员方法
        def __方法名...
    私有成员变量无法直接调用

9.继承
    单继承
    class 类名(父类名):
        类内容体
    多继承
    class 类名(父类1，父类2,....):
        类内容体
    pass 关键字 占位

10 重写父类成员和调用父类方法
    重写
    直接重写
    调用
    直接调用
    方式1：
        父类名.成员变量
        父类名.成员方法(self)
    方式2:
        super().成员变量
        super().成员方法()
11.变量类型的注解
支持:
    变量的类型注解
    函数(方法)形参列表和返回值的类型注解

    为变量设置类型注解
    变量: 类型
    var_1: int = 10
    stu: Student = Student
    基础容器类型注解
    my_list: list = [1,2,3]
    容器类型详细注解
    my_list: list[int] = {1,2,3}
    my_tuple: tuple[str,int,bool] = ("itheima",666,True)
    my_dict: dict[str,int] = ...

    函数(方法)形参列表和返回值的类型注解
        def func(data:list):
            data.app

        def 方法名(形参:类型,...,形参:类型) -> 返回值类型:
            pass

    Union联合类型注解:
        from typing import union
        my_list: list[union[str,int]]=[1,2,"itheima"]
        str,int 都可以
12. 多态
多态: 是指 多种状态，即完成某个行为时，使用不同的对象会得到不同的状态
父类被多个子类继承

抽象类(接口):
    父类的方法是空实现
    Class Animal:
        def speak(slef):
            pass
    Class Dog(Animal):
        def speak(slef):
            print("汪汪汪")
    Class Cat(Animal):
        def speak(slef):
            print("喵喵喵")
    抽象类: 含有抽象方法的类称之为抽象类
    抽象方法:方法体是空实现的(pass)称之为抽象方法
    抽象类就好比定义一个标准，包含了一些抽象的方法，要求子类必须实现


# Python操作数据库
    pip install pymysql
    from pymysql import Connerction
    conn = Connerction(
        host='localhost',
        port=3306,
        user='root',
        password='123456',
        autocommit=True # 设置自动提交
    )
    print(conn.get_server_info())
    # 获取游标对象
    cursor = conn.cursor()
    conn.select_db("test")
    # 使用游标对象,执行sql语句
    cursor.execute("CREATE TABLE test_pymysql(id INT,info VARCHAR(255))")

    cursor.execute("insert into student values("...")")
    这样无法插入数据
    还要通过 链接对象.commit()即可确认此行为

    conn.close()

# 闭包




# 装饰器

5 abc acd adf acd efdf